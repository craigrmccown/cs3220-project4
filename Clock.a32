; Addresses for I/O
.NAME	HEX = 0xFFFFF000
.NAME	LEDR = 0xFFFFF020
.NAME	KEY = 0xFFFFF080
.NAME	SW = 0xFFFFF090
.NAME	TCNT = 0xFFFFF100
.NAME	TLIM = 0xFFFF0104
.NAME	TCTRL = 0xFFFF0108
.NAME   STACK = 0x8000

.ORIG 0x100

; Set initial register values
;
; S0 is seconds
; S1 is minutes
; S2 is hours
; S3 is device addresses
; S4 is timer limit
Main:
XOR		Zero,Zero,Zero          ; Set Zero register to 0
LW      SP,StackAddr(Zero)      ; Initialize stack pointer
ADD     FP,SP,Zero              ; Initialize frame pointer
ADDI    S0,Zero,0x50            ; Set seconds to 50
ADDI    S1,Zero,0x59            ; Set minutes to 59
ADDI    S2,Zero,0x23            ; Set hours to 23
LW      S3,TLimAddr(Zero)       ; Load timer limit address
ADDI	S4,Zero,1000            ; Set timer limit to 1000
SW		S4,0(S3)                ; Store 1000 as the timer limit
LW      S4,TCtrlAddr(Zero)      ; Load timer control address

SW      FP,0(SP)                ; Store frame pointer
ADDI    SP,SP,12                ; Allocate memory for RA and RV
ADD     A0,S1,Zero              ; Arg 1
ADD     A1,S2,Zero              ; Arg 2 
ADD     A2,S3,Zero              ; Arg 3
CALL    DisplayClock(Zero)      ; Display clock value

ClockLoop:
LW		S4,0(S3)                ; Load current timer control bits
BEQ		S4,Zero,ClockLoop       ; Loop unless a second has passed

SW      FP,0(SP)                ; Store frame pointer
ADDI    SP,SP,12                ; Allocate memory for RA and RV
CALL    IncClock(Zero)          ; Increment clock every second

SW      FP,0(SP)                ; Store frame pointer
ADDI    SP,SP,12                ; Allocate memory for RA and RV
ADD     A0,S1,Zero              ; Arg 1
ADD     A1,S2,Zero              ; Arg 2 
ADD     A2,S3,Zero              ; Arg 3
CALL    DisplayClock(Zero)      ; Display clock value

SW      Zero,0(S3)              ; Clear ready bit
BR      ClockLoop               ; Loop forever

; Displays the current time on the HEX display
;
; A0 is seconds
; A1 is minutes
; A2 is hours
; S0 is clock value
; T0 is seconds
; T1 is shifted minutes
; T2 is shifted hours
DisplayClock:
ADDI    SP,SP,16                ; Push stack
SW      RA,4(FP)                ; Store return address
SW      A0,-16(SP)              ; Store arg 1
SW      A1,-12(SP)              ; Store arg 2
SW      A2,-8(SP)               ; Store arg 3
SW      S0,-4(SP)               ; Save S0

SW      FP,0(SP)                ; Store frame pointer
ADD     FP,SP,Zero              ; Set frame pointer to new record
ADDI    SP,SP,12                ; Allocate memory for RA and RV
ADD     A0,A1,Zero              ; Arg 1
CALL    ByteShift(Zero)         ; Left shift 8 bits
ADD     T1,RV,Zero              ; Grab return value

LW      T0,-16(SP)              ; Get seconds from stack
LW      T2,-8(SP)               ; Get hours from stack
XOR     S0,S0,S0                ; Set clock value to 0
OR      S0,T0,T1                ; Clock value holds seconds and minutes

SW      FP,0(SP)                ; Store frame pointer
ADD     FP,SP,Zero              ; Set frame pointer to new record
ADDI    SP,SP,12                ; Allocate memory for RA and RV
ADD     A0,T2,Zero              ; Arg 1
CALL    ByteShift(Zero)         ; Left shift 8 bits
ADD     T2,RV,Zero              ; Grab return value

SW      FP,0(SP)                ; Store frame pointer
ADD     FP,SP,Zero              ; Set frame pointer to new record
ADDI    SP,SP,12                ; Allocate memory for RA and RV
ADD     A0,T2,Zero              ; Arg 1
CALL    ByteShift(Zero)         ; Left shift 8 bits
ADD     T2,RV,Zero              ; Grab return value

OR      S0,S0,T2                ; Clock value holds seconds, minutes, and hours
SW      S0,HEX(Zero)            ; Display the clock value on the HEX pins

DisplayClockRet:
LW      S0,-4(SP)               ; Restore S0
LW      RA,4(FP)                ; Load return address
ADD     SP,FP,Zero              ; Pop stack
LW      FP,0(FP)                ; Restore old frame pointer
RET

; Shifts a value up one byte
;
; T0 is seconds
; T1 is minutes
; T2 is hours
; T3 is unshifted value
; T4 is loop counter
ByteShift:
SW      RA,4(FP)                ; Store return address
ADDI    SP,SP,8                 ; Push stack
SW      A0,-4(SP)               ; Store arg 1

ADDI    T0,Zero,8               ; Set loop counter to 8

ByteShiftLoop:
ADD     A0,A0,A0                ; Left shift 1 bit
SUBI    T0,T0,1                 ; Decrement loop counter
BNE     T0,Zero,ByteShiftLoop   ; Loop 8 times

ByteShiftRet:
LW      RA,4(FP)                ; Load return address
ADD     SP,FP,Zero              ; Pop stack
LW      FP,0(SP)                ; Restore old frame pointer
RET

; Increments clock value
;
; S0 is seconds
; S1 is minutes
; S2 is hours
; T0 is overflow value
; T1 is current digit
IncClock:
SW      RA,4(FP)                ; Store return address

ADDI    T0,Zero,0x59            ; Set overflow value to 59
BEQ     T0,S0,IncMin            ; Go to IncMin if there are 59 seconds
ADDI    T0,Zero,0x9             ; Set overflow value to 9
ADD     T1,Zero,S0              ; Set current digit to seconds
ANDI    T1,T1,0xF               ; Mask to get least significant digit
BEQ     T0,T1,SecOverflow       ; Go to SecOverflow if the least significant digit is 9
ADDI    S0,S0,1                 ; Otherwise, increment seconds
BR      IncClockRet

SecOverflow:
ADDI    S0,S0,0x10              ; Add 10 seconds
ANDI    S0,S0,0xF0              ; Set least significant digit to 0
BR      IncClockRet

IncMin:
XOR     S0,S0,S0                ; Clear seconds
ADDI    T0,Zero,0x59            ; Set overflow value to 59
BEQ     T0,S1,IncHour           ; Go to IncHour if there are 59 minutes
ADDI    T0,Zero,0x9             ; Set overflow value to 9
ADD     T1,Zero,S1              ; Set current digit to minutes
ANDI    T1,T1,0xF               ; Mask to get least significant digit
BEQ     T0,T1,MinOverflow       ; Go to MinOverflow if the least significant digit is 9
ADDI    S1,S1,1                 ; Otherwise, increment minutes
BR      IncClockRet

MinOverflow:
ADDI    S1,S1,0x10              ; Add 10 minutes
ANDI    S1,S1,0xF0              ; Set least significant digit to 0
BR      IncClockRet

IncHour:
XOR     S1,S1,S1                ; Clear minutes
ADDI    T0,Zero,0x23            ; Set overflow value to 23
BEQ     T0,S2,Rollover          ; Go to Rollover if there are 23 hours
ADDI    T0,Zero,0x9             ; Set overflow value to 9
ADD     T1,Zero,S2              ; Set current digit to hours
ANDI    T1,T1,0xF               ; Mask to get least significant digit
BEQ     T0,T1,HourOverflow      ; Go to HourOverflow if the least significant digit is 9
ADDI    S2,S2,1                 ; Otherwise, increment hours
BR      IncClockRet

HourOverflow:
ADDI    S2,S2,0x10              ; Add 10 hours
ANDI    S2,S2,0xF0              ; Set least significant digit to 0
BR      IncClockRet

Rollover:
XOR     S2,S2,S2                ; Clear hours
BR      IncClockRet

IncClockRet:
LW      RA,4(FP)                ; Load return address
ADD     SP,FP,Zero              ; Pop stack
LW      FP,0(SP)                ; Restore old frame pointer
RET

; Static data
TLimAddr:
.WORD TLIM
TCtrlAddr:
.WORD TCTRL
StackAddr:
.WORD STACK
