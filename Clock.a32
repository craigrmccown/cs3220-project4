; Addresses for I/O
.NAME	HEX = 0xFFFFF000
.NAME	LEDR = 0xFFFFF020
.NAME	KEY = 0xFFFFF080
.NAME   KCTRL = 0xFFFFF084
.NAME	SW = 0xFFFFF090
.NAME   SCTRL = 0xFFFFF094
.NAME	TCNT = 0xFFFFF100
.NAME	TLIM = 0xFFFF0104
.NAME	TCTRL = 0xFFFF0108
.NAME   STACK = 0x8000
.NAME   TESTVAL = 0xBEEFED

.ORIG 0x100

; Set initial register values
;
; S0 is seconds
; S1 is minutes
; S2 is hours
; S3 is device addresses
; T0 is device values
Main:
XOR		Zero,Zero,Zero              ; Set Zero register to 0
LW      SP,StackAddr(Zero)          ; Initialize stack pointer
ADD     FP,SP,Zero                  ; Initialize frame pointer
ADDI    S0,Zero,0x50                ; Set seconds to 50
ADDI    S1,Zero,0x59                ; Set minutes to 59
ADDI    S2,Zero,0x23                ; Set hours to 23
LW      S3,TLimAddr(Zero)           ; Load timer limit address
ADDI	T0,Zero,1000                ; Set timer limit to 1000
SW		T0,0(S3)                    ; Store 1000 as the timer limit
LW      S3,TCtrlAddr(Zero)          ; Load timer control address

SW      FP,0(SP)                    ; Store frame pointer
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
ADD     A0,S0,Zero                  ; Arg 1: seconds
ADD     A1,S1,Zero                  ; Arg 2: minutes
ADD     A2,S2,Zero                  ; Arg 3: hours
CALL    DisplayClock(Zero)          ; Display clock value

DisplayMode:
LW      T0,KCTRL(Zero)              ; Load current key control bits
BNE     T0,Zero,SetTransition       ; Go to KeyPressHandler if key is pressed
LW		T0,0(S3)                    ; Load current timer control bits
BEQ		T0,Zero,DisplayMode         ; Loop unless a second has passed

SW      FP,0(SP)                    ; Store frame pointer
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
CALL    IncAndDisplay(Zero)         ; Tick clock

SW      Zero,0(S3)                  ; Clear ready bit
BR      DisplayMode                 ; Loop forever

; Increments clock and displays the incremented value on the HEX pins
IncAndDisplay:
SW      RA,4(FP)                    ; Store return address

SW      FP,0(SP)                    ; Store frame pointer
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
CALL    IncClock(Zero)              ; Increment clock every second

SW      FP,0(SP)                    ; Store frame pointer
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
ADD     A0,S0,Zero                  ; Arg 1: seconds
ADD     A1,S1,Zero                  ; Arg 2: minutes
ADD     A2,S2,Zero                  ; Arg 3: hours
CALL    DisplayClock(Zero)          ; Display clock value

IncAndDisplayRet:
LW      RA,4(FP)                    ; Load return address
ADD     SP,FP,Zero                  ; Pop stack
LW      FP,0(FP)                    ; Restore old frame pointer
RET

; Displays the current time on the HEX display
;
; A0 is seconds
; A1 is minutes
; A2 is hours
; S0 is clock value
; T0 is seconds
; T1 is shifted minutes
DisplayClock:
ADDI    SP,SP,16                    ; Push stack
SW      RA,4(FP)                    ; Store return address
SW      A0,-16(SP)                  ; Store arg 1
SW      A1,-12(SP)                  ; Store arg 2
SW      A2,-8(SP)                   ; Store arg 3
SW      S0,-4(SP)                   ; Save S0

ADD     A0,A1,Zero                  ; Arg 1: minutes
SW      FP,0(SP)                    ; Store frame pointer
ADD     FP,SP,Zero                  ; Set frame pointer to new record
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
CALL    ByteShift(Zero)             ; Left shift 8 bits
ADD     T1,RV,Zero                  ; Grab return value

LW      T0,-16(SP)                  ; Get seconds from stack
XOR     S0,S0,S0                    ; Set clock value to 0
OR      S0,T0,T1                    ; Clock value holds seconds and minutes

LW      A0,-8(SP)                   ; Arg 1: hours
SW      FP,0(SP)                    ; Store frame pointer
ADD     FP,SP,Zero                  ; Set frame pointer to new record
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
CALL    ByteShift(Zero)             ; Left shift 8 bits

ADD     A0,RV,Zero                  ; Grab return value and put into arg 1
SW      FP,0(SP)                    ; Store frame pointer
ADD     FP,SP,Zero                  ; Set frame pointer to new record
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
CALL    ByteShift(Zero)             ; Left shift 8 bits

OR      S0,S0,RV                    ; Clock value holds seconds, minutes, and hours
SW      S0,HEX(Zero)                ; Display the clock value on the HEX pins

DisplayClockRet:
LW      S0,-4(SP)                   ; Restore S0
LW      RA,4(FP)                    ; Load return address
ADD     SP,FP,Zero                  ; Pop stack
LW      FP,0(FP)                    ; Restore old frame pointer
RET

; Shifts a value up one byte
;
; A0 is value to shift
; T0 is loop counter
ByteShift:
SW      RA,4(FP)                    ; Store return address
ADDI    SP,SP,4                     ; Push stack
SW      A0,-4(SP)                   ; Store arg 1

ADDI    T0,Zero,8                   ; Set loop counter to 8

ByteShiftLoop:
ADD     A0,A0,A0                    ; Left shift 1 bit
SUBI    T0,T0,1                     ; Decrement loop counter
BNE     T0,Zero,ByteShiftLoop       ; Loop 8 times

ByteShiftRet:
LW      RA,4(FP)                    ; Load return address
ADD     SP,FP,Zero                  ; Pop stack
ADD     RV,A0,Zero                  ; Return shifted value
LW      FP,0(FP)                    ; Restore old frame pointer
RET

; Increments clock value
;
; S0 is seconds
; S1 is minutes
; S2 is hours
; T0 is overflow value
; T1 is current digit
IncClock:
SW      RA,4(FP)                    ; Store return address

ADDI    T0,Zero,0x59                ; Set overflow value to 59
BEQ     T0,S0,IncMin                ; Go to IncMin if there are 59 seconds
ADDI    T0,Zero,0x9                 ; Set overflow value to 9
ADD     T1,Zero,S0                  ; Set current digit to seconds
ANDI    T1,T1,0xF                   ; Mask to get least significant digit
BEQ     T0,T1,SecOverflow           ; Go to SecOverflow if the least significant digit is 9
ADDI    S0,S0,1                     ; Otherwise, increment seconds
BR      IncClockRet

SecOverflow:
ADDI    S0,S0,0x10                  ; Add 10 seconds
ANDI    S0,S0,0xF0                  ; Set least significant digit to 0
BR      IncClockRet

IncMin:
XOR     S0,S0,S0                    ; Clear seconds
ADDI    T0,Zero,0x59                ; Set overflow value to 59
BEQ     T0,S1,IncHour               ; Go to IncHour if there are 59 minutes
ADDI    T0,Zero,0x9                 ; Set overflow value to 9
ADD     T1,Zero,S1                  ; Set current digit to minutes
ANDI    T1,T1,0xF                   ; Mask to get least significant digit
BEQ     T0,T1,MinOverflow           ; Go to MinOverflow if the least significant digit is 9
ADDI    S1,S1,1                     ; Otherwise, increment minutes
BR      IncClockRet

MinOverflow:
ADDI    S1,S1,0x10                  ; Add 10 minutes
ANDI    S1,S1,0xF0                  ; Set least significant digit to 0
BR      IncClockRet

IncHour:
XOR     S1,S1,S1                    ; Clear minutes
ADDI    T0,Zero,0x23                ; Set overflow value to 23
BEQ     T0,S2,Rollover              ; Go to Rollover if there are 23 hours
ADDI    T0,Zero,0x9                 ; Set overflow value to 9
ADD     T1,Zero,S2                  ; Set current digit to hours
ANDI    T1,T1,0xF                   ; Mask to get least significant digit
BEQ     T0,T1,HourOverflow          ; Go to HourOverflow if the least significant digit is 9
ADDI    S2,S2,1                     ; Otherwise, increment hours
BR      IncClockRet

HourOverflow:
ADDI    S2,S2,0x10                  ; Add 10 hours
ANDI    S2,S2,0xF0                  ; Set least significant digit to 0
BR      IncClockRet

Rollover:
XOR     S2,S2,S2                    ; Clear hours
BR      IncClockRet

IncClockRet:
LW      RA,4(FP)                    ; Load return address
ADD     SP,FP,Zero                  ; Pop stack
LW      FP,0(FP)                    ; Restore old frame pointer
RET

SetTransition:
LW      S4,TCNT(Zero)               ; Store initial clock value
XOR     S5,S5,S5                    ; Zero out the transition elapsed count

SetTransitionLoop:
LW      T0,0(S3)                    ; Load timer control value
BNE     T0,Zero,SetTransitionTick   ; Go to SetTransitionTick if timer reaches limit
LW      T0,TCNT(Zero)               ; Load current timer count
BEQ     S4,T0,SetTransitionElapse   ; Go to SetTransitionElapse if timer wraps back around
LW      T0,KCTRL(Zero)              ; Load key control value
BEQ     T0,Zero,SetTransitionLoop   ; Loop if key is still down
LW      T0,KEY(Zero)                ; Load key value
BEQ     T0,Zero,DisplayMode         ; Go back to display mode if no keys are pressed
BR      SetTransitionLoop           ; Loop if any keys are still down

SetTransitionTick:
SW      FP,0(SP)                    ; Store frame pointer
ADDI    SP,SP,12                    ; Allocate memory for RA and RV
CALL    IncAndDisplay(Zero)         ; Tick clock

BR      SetTransitionLoop           ; Continue with transition period

SetTransitionElapse:
ADDI    S5,S5,1                     ; Increment elapsed count
ADDI    T0,Zero,2                   ; Load 2 into T0
BNE     S5,T0,SetTransitionLoop     ; Loop if less than 2 seconds have elapsed

SetTransitionEnd:
LW      T0,TestVal(Zero)
SW      T0,HEX(Zero)

SetTransitionEndLoop:
BR      SetTransitionEndLoop

; Static data
TLimAddr:
.WORD TLIM
TCtrlAddr:
.WORD TCTRL
StackAddr:
.WORD STACK
TestVal:
.WORD TESTVAL
