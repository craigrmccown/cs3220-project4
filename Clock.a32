; Addresses for I/O
.NAME	HEX = 0xFFFFF000
.NAME	LEDR = 0xFFFFF020
.NAME	KEY = 0xFFFFF080
.NAME	SW = 0xFFFFF090
.NAME	TCNT = 0xFFFFF100
.NAME	TLIM = 0xFFFF0104
.NAME	TCTRL = 0xFFFF0108
.NAME   STACK = 0x8000

.ORIG 0x100

; Set initial register values
;
; T0 is seconds
; T1 is minutes
; T2 is hours
; T3 is device addresses
; T4 is timer limit
Init:
XOR		Zero,Zero,Zero          ; Set Zero register to 0
LW      SP,StackAddr(Zero)      ; Initialize stack pointer
ADDI    T0,Zero,0x50            ; Set seconds to 50
ADDI    T1,Zero,0x59            ; Set minutes to 59
ADDI    T2,Zero,0x23            ; Set hours to 23
CALL    DisplayClock(Zero)      ; Display clock value
LW      T3,TLimAddr(Zero)       ; Load timer limit address
ADDI	T4,Zero,1000            ; Set timer limit to 1000
SW		T4,0(T3)                ; Store 1000 as the timer limit
LW      T3,TCtrlAddr(Zero)      ; Load timer control address

; Main clock loop
;
; T0 is seconds
; T1 is minutes
; T2 is hours
; T3 is timer control address
; T4 is timer control value
ClockLoop:
LW		T4,0(T3)                ; Load current timer control bits
BEQ		T4,Zero,ClockLoop       ; Loop unless a second has passed
CALL    IncClock(Zero)          ; Increment clock every second
CALL    DisplayClock(Zero)      ; Display clock value
ADDI    T6,Zero,0xDEAD          ; temp      
SW      T6,HEX(Zero)            ; temp
LW      T3,TCtrlAddr(Zero)      ; Load timer control address
SW      Zero,0(T3)              ; Clear ready bit
BR      ClockLoop               ; Loop forever

; Returns from function
;
; SP is stack pointer
; RA is return address
Return:
LW      RA,0(SP)                ; Load previous return address
SUBI    SP,SP,4                 ; Pop stack
RET

; Displays the current time on the HEX display
;
; T0 is seconds
; T1 is minutes
; T2 is hours
; T3 is shifted values
; T4 is clock value
DisplayClock:
ADDI    SP,SP,4                 ; Push stack
SW      RA,0(SP)                ; Store return address
ADD     T3,T1,Zero              ; Set shifted value to minutes
CALL    ByteShift(Zero)         ; Left shift 8 bits
XOR     T4,T4,T4                ; Set clock value to 0
OR      T4,T0,T3                ; Clock value holds seconds and minutes
ADDI    SP,SP,4                 ; Push stack
SW      T4,0(SP)                ; Store partial result on stack
ADD     T3,T2,Zero              ; Set shifted value to hours
CALL    ByteShift(Zero)         ; Left shift 8 bits
CALL    ByteShift(Zero)         ; Left shift 8 more bits
LW      T4,0(SP)                ; Load partial result from stack
SUBI    SP,SP,1                 ; Pop stack
OR      T4,T4,T3                ; Clock value holds seconds, minutes, and hours
SW      T4,HEX(Zero)            ; Display the clock value on the HEX pins
BR      Return

; Shifts a value up one byte
;
; T0 is seconds
; T1 is minutes
; T2 is hours
; T3 is unshifted value
; T4 is loop counter
ByteShift:
ADDI    SP,SP,4                 ; Push stack
SW      RA,0(SP)                ; Store return address
ADDI    T4,Zero,8               ; Set loop counter to 8

ByteShiftLoop:
ADD     T3,T3,T3                ; Left shift 1 bit
SUBI    T4,T4,1                 ; Decrement loop counter
BNE     T4,Zero,ByteShiftLoop   ; Loop 8 times
BR      Return

; Increments clock value
;
; T0 is seconds
; T1 is minutes
; T2 is hours
; T3 is overflow value
; T4 is current digit
IncClock:
ADDI    SP,SP,4                 ; Push stack
SW      RA,0(SP)                ; Store return address
ADDI    T3,Zero,0x59            ; Set overflow value to 59
BEQ     T3,T0,IncMin            ; Go to IncMin if there are 59 seconds
ADDI    T3,Zero,0x9             ; Set overflow value to 9
ADD     T4,Zero,T0              ; Set current digit to seconds
ANDI    T4,T4,0xF               ; Mask to get least significant digit
BEQ     T3,T4,SecOverflow       ; Go to SecOverflow if the least significant digit is 9
ADDI    T0,T0,1                 ; Otherwise, increment seconds
BR      Return

SecOverflow:
ADDI    T0,T0,0x10              ; Add 10 seconds
ANDI    T0,T0,0xF0              ; Set least significant digit to 0
BR      Return

IncMin:
XOR     T0,T0,T0                ; Clear seconds
ADDI    T3,Zero,0x59            ; Set overflow value to 59
BEQ     T3,T1,IncHour           ; Go to IncHour if there are 59 minutes
ADDI    T3,Zero,0x9             ; Set overflow value to 9
ADD     T4,Zero,T1              ; Set current digit to minutes
ANDI    T4,T4,0xF               ; Mask to get least significant digit
BEQ     T3,T4,MinOverflow       ; Go to MinOverflow if the least significant digit is 9
ADDI    T1,T1,1                 ; Otherwise, increment minutes
BR      Return

MinOverflow:
ADDI    T1,T1,0x10              ; Add 10 minutes
ANDI    T1,T1,0xF0              ; Set least significant digit to 0
BR      Return

IncHour:
XOR     T1,T1,T1                ; Clear minutes
ADDI    T3,Zero,0x23            ; Set overflow value to 23
BEQ     T3,T2,Rollover          ; Go to Rollover if there are 23 hours
ADDI    T3,Zero,0x9             ; Set overflow value to 9
ADD     T4,Zero,T2              ; Set current digit to hours
ANDI    T4,T4,0xF               ; Mask to get least significant digit
BEQ     T3,T4,HourOverflow      ; Go to HourOverflow if the least significant digit is 9
ADDI    T2,T2,1                 ; Otherwise, increment hours
BR      Return

HourOverflow:
ADDI    T2,T2,0x10              ; Add 10 hours
ANDI    T2,T2,0xF0              ; Set least significant digit to 0
BR      Return

Rollover:
XOR     T2,T2,T2                ; Clear hours
BR      Return

; Static data
TLimAddr:
.WORD TLIM
TCtrlAddr:
.WORD TCTRL
StackAddr:
.WORD STACK
